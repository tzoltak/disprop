% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/dysprop.R
\name{var_disprop}
\alias{var_disprop}
\title{Wariancja (wazona wariancja odsetkow).}
\usage{
var_disprop(x, y, unorm = NULL, komponent = NULL)
}
\arguments{
\item{x}{wektor ważony}

\item{y}{wektor ważący}

\item{unorm}{stała normująca lub NULL, jeśli współczynnik ma nie być normowany -
p. szczegóły}

\item{komponent}{opcjonalnie lista wektorów definiujących podział na komponenty;
kolejne elementy listy definiują kolejne poziomy podziału (przy czym podział na każdym
kolejnym poziomie będzie traktowany jako zagnieżdżony w poziomach wyższych)}
}
\value{
funkcja zwraca wartość liczbową
}
\description{
Wylicza "ważoną wariancję odsetków" - wariancję zaadaptowaną do roli miary
dysproporcjonalności.
}
\details{
Uwaga, porównywane wektory nie mogą zawierać braków danych!

W przypadku normowania wartości wskaźnika istnieją dwa typowe wybory wartości stałej
normującej:
\itemize{
  \item{1 - w takim wypadku zwrócony zostanie kwadrat "ważonego współczynnika
        zmienności odsetków", czyli wartość wskaźnika zostanie podzielona przez kwadrat
        ilorazu \code{sum(x) / sum(y)}. Tak przekształcony wskaźnik nie posiada
        ograniczenia górnego w 1 i dekomponuje się w nieco inny sposób (p. przykłady).}
  \item{Liczba obiektów w analizowanej zbiorowości. Jeśli wartość wskaźnika, oprócz
        podzielenia przez przez kwadrat ilorazu \code{sum(x) / sum(y)}, zostanie
        podzielona również przez liczbę obiektów w analizowanej zbiorowości, to dla
        liczby obiektów zbiegającej do nieskończoności będzie on posiadał ograniczenie
        górne w 1, wyznaczane przez sytuację, gdy cała wartość x skupiona jest w jednym
        obiekcie. Oczywiście unormowanie to ma sens, o ile w ramach rozpatrywanego
        problemu daje się sensownie wyróżnić liczbę obiektów w zbiorowości (typowo może
        to być suma \code{y}). Tak wyliczony wskaźnik nie poddaje się dekompozycji.}
}
Pewien problem ze wskaźnikiem polega na tym, że jego wartość bardzo szybko spada nawet
przy niewielkich odstępstwach od maksymalnej możliwej dysproporcjonalności, co jest
niezbyt intuicyjne (szczególnie wyraźnie widać to w przypadku drugiego z ww. typów
unormowania) - p. przykłady.
}
\examples{
vTG=c(10,40,50)
sTG=c(15,25,60)
var_disprop(sTG, vTG)

# przykład dekomponowalności
dane = data.frame(
  gr = rep(1:3, each=3),
  v  = c(150, 90, 100, 120, 80, 70, 200, 20, 30),
  s  = c(  3,  2,   2,   5,  1,  1,   3,  0,  0)
)
wewnGrup = c(
  gr1 = with(subset(dane, gr==1), var_disprop(s, v)),
  gr2 = with(subset(dane, gr==2), var_disprop(s, v)),
  gr3 = with(subset(dane, gr==3), var_disprop(s, v))
)
sumy = aggregate(dane[, -1], list(gr=dane$gr), sum)
wewnGrup = weighted.mean(wewnGrup, sumy$v)
miedzyGrup = with(sumy, var_disprop(s, v))
miedzyGrup + wewnGrup
( ogolem = with(dane, var_disprop(s, v)) )
all.equal(miedzyGrup + wewnGrup, ogolem)

# przykład własności unormowań
n = c(10, 100, 1000)
zestawienie = matrix(NA, nrow=6, ncol=length(n),
  dimnames=list(c("Gini n1=1", "Gini n1=2", "var  n1=1, unorm=n",
                  "var  n1=2, unorm=n", "var  n1=1, unorm=1", "var  n1=2, unorm=1"),
                paste0("n=", n)))
for(i in 1:length(n)) {
  zestawienie[, i] = c(
    gini_disprop(c(1,0), c(1, n[i]-1)),
    gini_disprop(c(1,0), c(2, n[i]-2)),
    var_disprop (c(1,0), c(1, n[i]-1), n[i]),
    var_disprop (c(1,0), c(2, n[i]-2), n[i]),
    var_disprop (c(1,0), c(1, n[i]-1), 1),
    var_disprop (c(1,0), c(2, n[i]-2), 1)
  )
}
zestawienie
# n1=1 oznacza, że jeden obiekt posiada wszystko (a n-1 obiektów nie posiada nic)
# n1=2 oznacza, że dwa obiekty posiadają wszystko (a n-2 obiektów nie posiada nic)

# dekompozycja wskaźnika wyliczonego z unorm=1
dane = data.frame(
  gr = rep(1:3, each=3),
  v  = c(150, 90, 100, 120, 80, 70, 200, 20, 30),
  s  = c(  3,  2,   2,   5,  1,  1,   3,  0,  0)
)
wewnGrup = c(
  gr1 = with(subset(dane, gr==1), var_disprop(s, v, unorm=1)),
  gr2 = with(subset(dane, gr==2), var_disprop(s, v, unorm=1)),
  gr3 = with(subset(dane, gr==3), var_disprop(s, v, unorm=1))
)
sumy = aggregate(dane[, -1], list(gr=dane$gr), sum)
wewnGrup = weighted.mean(wewnGrup * with(sumy, {(s / v)^2 / (sum(s) / sum(v))^2}),
                         sumy$v)
miedzyGrup = with(sumy, var_disprop(s, v, unorm=1))
miedzyGrup + wewnGrup
( ogolem = with(dane, var_disprop(s, v, unorm=1)) )
all.equal(miedzyGrup + wewnGrup, ogolem)
}

